[{"section":"Blog","slug":"/blog/post-2/","title":"Bulk RNA-seq (7): From ENSEMBL ID Cleanup to Gene Name Conversion","description":"this is meta description","date":"August 15, 2022","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/PCA_hu87be8c1307d3013bc46fdca9c9c0afca_306677_420x0_resize_q100_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"210\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/PCA_hu87be8c1307d3013bc46fdca9c9c0afca_306677_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/PCA_hu87be8c1307d3013bc46fdca9c9c0afca_306677_100x100_fill_q100_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/PCA_hu87be8c1307d3013bc46fdca9c9c0afca_306677_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"RNA-seq","tags":"RNA-seq, Scripts, R","content":" Note\nIn the realm of RNA-seq analysis, one often encounters the challenge of working with ENSEMBL IDs that include decimal points, a result of gene versioning in databases. Furthermore, for meaningful biological interpretation, it\u0026rsquo;s essential to convert these ENSEMBL IDs to more recognizable gene names. This blog post will guide you through the process of cleaning up these IDs and converting them for enhanced clarity in your analyses.\nGeneid Clean gene name ENSMUSG00000102693.2 ENSMUSG00000102693 4933401J01Rik ENSMUSG00000064842.3 ENSMUSG00000064842 Gm26206 \u0026hellip;\u0026hellip; \u0026hellip;\u0026hellip; \u0026hellip;\u0026hellip; Preparing Your Workspace with Essential R Packages Before diving into the data manipulation, ensure that your R environment is equipped with the necessary packages. Here\u0026rsquo;s how to install them:\ninstall.packages(\u0026#34;stringr\u0026#34;) if (!requireNamespace(\u0026#34;BiocManager\u0026#34;, quietly = TRUE)) install.packages(\u0026#34;BiocManager\u0026#34;) BiocManager::install(\u0026#34;clusterProfiler\u0026#34;) BiocManager::install(\u0026#34;biomaRt\u0026#34;) In the realm of RNA-seq analysis, one often encounters the challenge of working with ENSEMBL IDs that include decimal points, a result of gene versioning in databases. Furthermore, for meaningful biological interpretation, it\u0026rsquo;s essential to convert these ENSEMBL IDs to more recognizable gene names. This blog post will guide you through the process of cleaning up these IDs and converting them for enhanced clarity in your analyses.\nPreparing Your Workspace with Essential R Packages Before diving into the data manipulation, ensure that your R environment is equipped with the necessary packages. Here\u0026rsquo;s how to install them:\nLoad the installed packages into your R session:\ninstall.packages(\u0026#34;stringr\u0026#34;) if (!requireNamespace(\u0026#34;BiocManager\u0026#34;, quietly = TRUE)) install.packages(\u0026#34;BiocManager\u0026#34;) BiocManager::install(\u0026#34;clusterProfiler\u0026#34;) BiocManager::install(\u0026#34;biomaRt\u0026#34;) library(stringr) library(clusterProfiler) library(biomaRt) Cleaning Up ENSEMBL IDs First, we tackle the issue of decimal points in ENSEMBL IDs which are indicative of gene versions. For many downstream analyses, these versions are unnecessary and can be removed for simplicity.\n# Load your count data ENSEM \u0026lt;- read.table(file = \u0026#34;featurecounts.txt\u0026#34;, header = TRUE, sep = \u0026#34;\\t\u0026#34;) head(ENSEM$Geneid) # Remove decimal points from ENSEMBL IDs ENSEM$Geneid = unlist(str_split(ENSEM$Geneid, \u0026#34;[.]\u0026#34;, simplify = TRUE))[, 1] head(ENSEM$Geneid) # Save the cleaned data write.csv(ENSEM, file = \u0026#34;totalexonreads.csv\u0026#34;, quote = FALSE, row.names = FALSE) Converting ENSEMBL IDs to Gene Names With cleaned ENSEMBL IDs, the next step is to convert them into gene names, facilitating easier identification and interpretation of the genes involved in your study.\n# Reload the cleaned data mycounts \u0026lt;- read.csv(file = \u0026#34;totalexonreads.csv\u0026#34;, row.names = 1, header = TRUE) head(mycounts) # Initialize the ENSEMBL biomaRt dataset for mouse ensembl \u0026lt;- useMart(biomart = \u0026#34;ensembl\u0026#34;, dataset = \u0026#34;mmusculus_gene_ensembl\u0026#34;) # Specify the attributes of interest: ENSEMBL IDs and gene symbols attributes \u0026lt;- listAttributes(ensembl) attr \u0026lt;- c(\u0026#34;ensembl_gene_id\u0026#34;, \u0026#34;mgi_symbol\u0026#34;) # Perform the ID conversion value \u0026lt;- ENSEM$Geneid ids \u0026lt;- getBM(attributes = attr, filters = \u0026#34;ensembl_gene_id\u0026#34;, value = value, mart = ensembl) By employing the biomaRt package, you can seamlessly map ENSEMBL IDs to their corresponding gene symbols. This conversion not only aids in the readability of your results but also in their biological interpretation.\nThis ids will be very important for us to generate volcano plot!\n"},{"section":"Blog","slug":"/blog/normalization-and-pca-visualization-in-rna-seq-data-analysis-with-deseq2/","title":"Bulk RNA-seq (6): Normalization and PCA Visualization in RNA-seq Data Analysis with DESeq2","description":"this is meta description","date":"July 4, 2022","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/PCA_hu87be8c1307d3013bc46fdca9c9c0afca_306677_420x0_resize_q100_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"210\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/PCA_hu87be8c1307d3013bc46fdca9c9c0afca_306677_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/PCA_hu87be8c1307d3013bc46fdca9c9c0afca_306677_100x100_fill_q100_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/PCA_hu87be8c1307d3013bc46fdca9c9c0afca_306677_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"RNA-seq","tags":"RNA-seq, Scripts, R","content":" Note\nIn this blog post, we\u0026rsquo;ll dive into a practical guide on using DESeq2 for differential expression analysis in RNA-seq data. DESeq2 is a powerful R package designed for analyzing count-based NGS data like RNA-seq and ChIP-seq. Let\u0026rsquo;s break down the steps and code snippets used in this analysis:\nHow DESeq2 Calculates DEGs DESeq2, published in 2014 and cited over 30,000 times, is a method for differential analysis of count data. It utilizes shrinkage estimation for dispersions and fold changes, enhancing the stability and interpretability of estimates. (Reference )\nLibrary Normalization in DESeq2 (Median of Ratios Method) Unlike RPKM, FPKM, TPM, and other methods that adjust for differences in overall read counts among libraries, DESeq2 employs a unique approach. It addresses:\nDifferences in library sizes Differences in library composition (e.g., liver vs. spleen) DESeq2\u0026rsquo;s median of ratios method normalizes for sequencing depth and RNA composition with a straightforward user experience but involves multiple backend steps:\nStep 1: Creating a Pseudo-Reference Sample (Row-wise Geometric Mean) For each gene, a pseudo-reference sample is calculated as the geometric mean across all samples.\nGene ID Sample1 Sample2 pseudo-reference 1 1489 906 sqrt(1489 * 906) = 1161.5 2 22 13 sqrt(22 * 13) = 17.7 \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip; For instance, the pseudo-reference for Gene 1 is calculated as: $$ \\sqrt{1489*906} $$ Notice: If any count data equals 0, the pseudo-reference becomes 0, regardless of other counts.\nStep 2: Calculating Ratios to the Reference For each gene, the ratio of each sample\u0026rsquo;s count to the pseudo-reference count is calculated.\nGene ID Sample1 Sample2 pseudo-reference ratio of sample1/ref ratio of sample2/ref Gene 1 1489 906 1161.5 1489/1161.5 = 1.28 906/1161.5 = 0.78 Gene 2 22 13 16.9 22/16.9 = 1.30 13/16.9 = 0.77 \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip; Step 3: Determining the Normalization Factor (Size Factor) for Each Sample The median of all ratios for each sample is determined and used as the normalization factor for that sample. This method assumes that not all genes are differentially expressed, making it robust to imbalances in gene regulation and large numbers of DEGs.\nnormalization_factor_sample1 \u0026lt;- median(c(1.28, 1.3, ...)) normalization_factor_sample2 \u0026lt;- median(c(0.78, 0.77, ...)) Notice: Size factors are typically around 1.\nStep 4: Calculating Normalized Count Values Gene ID Sample1 Sample2 Gene 1 1489 / 1.3 = 1145.39 906 / 0.77 = 1176.62 Gene 2 22 / 1.3 = 16.92 13 / 0.77 = 16.88 … … … Normalized counts are calculated by dividing the original counts by the sample\u0026rsquo;s normalization factor. This process emphasizes moderately expressed genes over genes that consume a large proportion of reads.\nTherefore, additional normalization before using DESeq2 is not necessary as DESeq2\u0026rsquo;s method effectively accounts for key variables affecting RNA-seq data.\nUsing DESeq2 for normalization Preprocessing: Cleaning Up the Data Before diving into differential expression analysis, it\u0026rsquo;s crucial to clean up your data. This includes removing genes with zero reads across all samples, as they won\u0026rsquo;t contribute to the analysis.\n# Delete genes whose reads are all 0 mycounts1 \u0026lt;- mycounts[rowSums(mycounts) != 0,] By doing this, we ensure that the dataset only contains genes that have been expressed in at least one sample.\nSetting Up the Experiment Metadata Metadata contains information about your samples, such as conditions, treatments, or any relevant experimental groups. Correctly inputting this information is vital for the analysis.\n# Input metadata mymeta \u0026lt;- read.table(\u0026#34;metadata.txt\u0026#34;, stringsAsFactors = TRUE, header = TRUE) Ensure that the sample names in your metadata match the column names of your count data:\n# Check whether sample names match colnames(mycounts1) == mymeta$Sample Installing and Loading DESeq2 DESeq2 is available through Bioconductor, and here\u0026rsquo;s how you can install and load it:\n# Installation of DESeq2 package install.packages(\u0026#34;BiocManager\u0026#34;) BiocManager::install(\u0026#34;DESeq2\u0026#34;) # Load DESeq2 library(DESeq2) Preparing the DESeq2 Dataset Creating a DESeq dataset object (dds) is the first step in your differential expression analysis, linking your count data with the experimental metadata.\ndds \u0026lt;- DESeqDataSetFromMatrix(countData = mycounts1, colData = mymeta, design = ~Group) If you\u0026rsquo;re interested in comparing a specific group against a reference, you can set your reference group like this:\n# Setting the reference level for comparisons dds$Group \u0026lt;- relevel(dds$Group, ref=\u0026#34;WT\u0026#34;) Normalizing the Data Normalization is key to making fair comparisons between samples. DESeq2 does this using size factors:\ndds \u0026lt;- estimateSizeFactors(dds) Visualizing Data with PCA Principal Component Analysis (PCA) is a useful tool for visualizing the overall effect of treatments or conditions on your samples.\nlibrary(ggplot2) rld \u0026lt;- rlog(dds, blind = TRUE) pca \u0026lt;- DESeq2::plotPCA(rld, intgroup = \u0026#34;Group\u0026#34;) pca ggsave(\u0026#34;PCA.png\u0026#34;, units = \u0026#34;cm\u0026#34;, width = 20, height = 10, dpi = 1200) "},{"section":"Blog","slug":"/blog/streamlining-mapping-with-a-custom-linux-script/","title":"Bulk RNA-seq (5): Streamlining Mapping with a Custom Linux Script","description":"this is meta description","date":"June 30, 2022","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/mappingscripts_hu66a195306e7d03dd8abb316f1d6fa6b6_637620_420x0_resize_q100_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"252\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/mappingscripts_hu66a195306e7d03dd8abb316f1d6fa6b6_637620_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/mappingscripts_hu66a195306e7d03dd8abb316f1d6fa6b6_637620_100x100_fill_q100_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/mappingscripts_hu66a195306e7d03dd8abb316f1d6fa6b6_637620_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"RNA-seq","tags":"RNA-seq, Scripts","content":" Note\nTo overcome the inconvenience of manually mapping each RNA-seq sample to the reference genome, I\u0026rsquo;ve developed a Linux shell script. This script automates the mapping process using STAR, significantly enhancing efficiency by processing all samples in one go.\nHere\u0026rsquo;s a detailed explanation of the script and its functionality:\n#!/bin/bash # Set the directory for the reference genome GENOME_DIR=~/reference/genome/grcm39/index/ # Set the output directory for mapped files OUT_DIR=~/RNA-seq/mapping/hPRMT1/2307_3organs/hearts/Tmapping_0711/\t# Create an associative array to store output file prefixes declare -A arr arr=( [\u0026#34;LAB_410_13\u0026#34;]=\u0026#34;WT1_2\u0026#34; [\u0026#34;LAB_410_14\u0026#34;]=\u0026#34;WT2_2\u0026#34; [\u0026#34;LAB_410_15\u0026#34;]=\u0026#34;WT3_2\u0026#34; [\u0026#34;LAB_410_16\u0026#34;]=\u0026#34;WT4_2\u0026#34; [\u0026#34;LAB_410_17\u0026#34;]=\u0026#34;MUT1_2\u0026#34; [\u0026#34;LAB_410_18\u0026#34;]=\u0026#34;MUT2_2\u0026#34; [\u0026#34;LAB_410_19\u0026#34;]=\u0026#34;MUT3_2\u0026#34; [\u0026#34;LAB_410_20\u0026#34;]=\u0026#34;MUT4_2\u0026#34; ) # Loop through the associative array for key in \u0026#34;${!arr[@]}\u0026#34; do # Construct file names for R1 and R2 reads R1=\u0026#34;${key}_R1_val_1.fq.gz\u0026#34; R2=\u0026#34;${key}_R2_val_2.fq.gz\u0026#34; # Get the current output file prefix OUT_PREFIX=\u0026#34;${OUT_DIR}${arr[$key]}\u0026#34; # Execute STAR for mapping STAR --runThreadN 10 \\ --runMode alignReads \\ --readFilesCommand zcat \\ --twopassMode Basic \\ --outSAMtype BAM SortedByCoordinate \\ --genomeDir $GENOME_DIR \\ --readFilesIn $R1 $R2 \\ --outFileNamePrefix $OUT_PREFIX done Script Features:\nReference Genome Directory: Specifies where the reference genome is located. Output Directory: Designates where the script should save the BAM files resulting from mapping. Associative Array for Sample Prefixes: Maps unique identifiers to output file prefixes, streamlining file management and ensuring clarity in sample identification. Automated Mapping Loop: Iterates through each sample, automatically generating file names for paired-end reads and performing the mapping with STAR using predefined parameters. Running the Script:\nCopy the script into a file, for example, mapping_script.sh. Make the script executable: chmod +x mapping_script.sh. Execute the script: ./mapping_script.sh. This approach not only saves time by automating the mapping process for multiple samples but also ensures consistency and accuracy in RNA-seq data analysis, allowing researchers to focus on downstream analysis tasks.\n"},{"section":"Blog","slug":"/blog/mapping-and-quality-control-with-star-qualimap-and-featurecounts/","title":"Bulk RNA-seq (4): Mapping and Quality Control with STAR, Qualimap, and featureCounts","description":"this is meta description","date":"June 15, 2022","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/gGtLYrNR1af7jxW_hu7b7071b4195e7df5666eecdb10736f3a_449380_420x0_resize_q100_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"212\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/gGtLYrNR1af7jxW_hu7b7071b4195e7df5666eecdb10736f3a_449380_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/gGtLYrNR1af7jxW_hu7b7071b4195e7df5666eecdb10736f3a_449380_100x100_fill_q100_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/gGtLYrNR1af7jxW_hu7b7071b4195e7df5666eecdb10736f3a_449380_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"RNA-seq","tags":"RNA-seq","content":" Note\nThis section of the blog series will guide you through mapping RNA-seq read files to a genome index using STAR, performing quality control (QC) with Qualimap, and generating count data with featureCounts. Each step is crucial for ensuring the accuracy and reliability of RNA-seq data analysis.\n1. Installing STAR STAR (Spliced Transcripts Alignment to a Reference) is a widely used aligner for RNA-seq data. To install STAR, follow the official manual :\n# Download the latest STAR source from releases wget https://github.com/alexdobin/STAR/archive/2.7.9a.tar.gz tar -xzf 2.7.9a.tar.gz cd STAR-2.7.9a/source make STAR # Verify the installation STAR 2. Generating Genome Index Before mapping, it\u0026rsquo;s essential to generate a genome index. I used mouse genome data from GENCODE for this purpose.\nTo generate the genome index, create a new folder named index and run STAR:\n#create a new folder named as index mkdir /home/xxx/reference/index #running STAR for the generation of index STAR --runThreadN 10 --runMode genomeGenerate --genomeDir index/ --genomeFastaFiles GRCh38.p13.genome.fa --sjdbGTFfile gencode.v38.annotation.gtf --sjdbOverhang 35 3. Mapping with STAR in Two-Pass Mode Mapping in two-pass mode allows STAR to use splice junctions discovered in the first pass to improve alignment in the second pass:\nSTAR --runThreadN 10 \\ --runMode alignReads \\ --readFilesCommand zcat \\ --twopassMode Basic \\ --outSAMtype BAM SortedByCoordinate \\ --genomeDir ~/reference/genome/grcm39/index/ \\ --readFilesIn 2_R1_val_1.fq.gz 2_R2_val_2.fq.gz \\ --outFileNamePrefix ~/wkdir Mapping typically takes about 6 minutes per sample. The log.final.out file provides important statistics like mapping rate and number of multi-mappers.\n4. Quality Control with Qualimap Qualimap is a tool that provides additional QC metrics for mapping data. To run Qualimap on your BAM files:\n~/qualimap_v2.2.1/qualimap rnaseq -bam ~/dir/xxx.bam -gtf ~/dir/annotation.gtf -outdir ~/dir/WT1 --java-mem-size=8G Qualimap reports include the percentage of reads mapped and the proportion of reads mapped to exonic regions.\n5. Generating Count Data with featureCounts featureCounts quantifies read counts per gene based on the mapping results:\nfeatureCounts -s 2 -p -t gene -g gene_id -a ~/dir/annotation.gtf -o counts.txt *.bam Remove unnecessary columns for a cleaner count table:\ncut -f1,7-100 counts.txt \u0026gt; featurecounts.txt Through these steps, you can map RNA-seq reads, perform detailed quality control, and generate count data for downstream analysis, ensuring a robust foundation for exploring gene expression.\n"},{"section":"Blog","slug":"/blog/trim-the-read-files-using-trim_galore/","title":"bulk RNA-seq(3):Trim the read files using trim_galore","description":"this is meta description","date":"May 30, 2022","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/trim2_hu66a195306e7d03dd8abb316f1d6fa6b6_1243274_420x0_resize_q100_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"252\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/trim2_hu66a195306e7d03dd8abb316f1d6fa6b6_1243274_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/trim2_hu66a195306e7d03dd8abb316f1d6fa6b6_1243274_100x100_fill_q100_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/trim2_hu66a195306e7d03dd8abb316f1d6fa6b6_1243274_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"RNA-seq","tags":"RNA-seq, Quality Control","content":" Tip\nWe will install Trim Galore and trim the merged read files to improve the quality of our data.\n1. The Importance of Trimming Quality trimming reduces the overall number of reads but increases the total and proportion of uniquely mapped reads, yielding more useful data for downstream analyses. However, overly aggressive trimming can adversely affect subsequent analyses.\n:man_teacher: Trimming removes low-quality reads! It\u0026rsquo;s essential before mapping!\n:woman_teacher: Be cautious! Trimming might remove critical reads, including those considered low quality.\n:bulb: The decision to trim should be based on your project needs and FastQC results.\n2. Assessing Read Quality with FastQC Refer to my previous article for how to use FastQC.\n2.1 Per Base Sequence Quality :warning: The figure above shows that the last 10 base pairs are of low quality, especially the very last one (marked with a red circle). Therefore, I\u0026rsquo;ve decided to trim this sample.\n3. Trimming with Trim Galore Note\nOur guide follows the Trim Galore instructions .\n3.1 Installing Trim Galore Visit the download site on GitHub.\n# Download the trim galore tar.gz file tar -zxvf 0.6.7.tar.gz Verify the installation:\ntrim_galore -version trim_galore --help 3.2 Running Trim Galore trim_galore -q 25 --phred 33 --stringency 3 --length 30 --paired 1_R1.fastq.gz 1_R2.fastq.gz --gzip -o./cleandata Trimming a paired sample typically takes about 15 minutes.\n3.3 Automating Trimming with a Shell Script I have created a shell script to automate the trimming process with Trim Galore. This script is designed to trim paired-end sequencing files for a series of samples by specifying their prefixes.\n#!/bin/bash # Specify the output directory where trimmed files will be stored OUT_DIR=~/OUT_DIR # List of sample prefixes to process Prefixes=( \u0026#34;LAB_410_13\u0026#34; \u0026#34;LAB_410_14\u0026#34; \u0026#34;LAB_410_15\u0026#34; \u0026#34;LAB_410_16\u0026#34; \u0026#34;LAB_410_17\u0026#34; \u0026#34;LAB_410_18\u0026#34; \u0026#34;LAB_410_19\u0026#34; \u0026#34;LAB_410_20\u0026#34; \u0026#34;LAB_410_21\u0026#34; \u0026#34;LAB_410_22\u0026#34; \u0026#34;LAB_410_23\u0026#34; \u0026#34;LAB_410_24\u0026#34; \u0026#34;LAB_410_25\u0026#34; \u0026#34;LAB_410_26\u0026#34; \u0026#34;LAB_410_27\u0026#34; \u0026#34;LAB_410_28\u0026#34; ) # Loop through each prefix to construct file names for R1 and R2 reads and perform trimming for PREFIX in \u0026#34;${Prefixes[@]}\u0026#34; do R1=${PREFIX}_R1.fastq.gz R2=${PREFIX}_R2.fastq.gz # Execute Trim Galore with specified parameters trim_galore -q 25 --phred33 --stringency 3 --length 30 --paired $R1 $R2 --gzip -o $OUT_DIR done Script Explanation and Usage:\nOutput Directory (OUT_DIR): The path where the script saves the trimmed files. Modify this to suit your project structure. Sample Prefixes (Prefixes Array): This array holds the identifiers for the sample sets to be processed. These identifiers are crucial for generating the filenames for paired-end reads. Processing Loop: For each sample identifier in the Prefixes array, the script constructs the filenames for R1 and R2 reads and executes Trim Galore to trim these files. Trim Galore Command: The script runs Trim Galore with parameters set for quality (-q 25), encoding (--phred33), stringency (--stringency 3), minimum length (--length 30), and output compression (--gzip), directing the output to the specified directory. To run this script:\nSave the script into a file, e.g., trim_script.sh. Make the script executable by running chmod +x trim_script.sh. Execute the script with ./trim_script.sh in your terminal. This script aims to streamline the preprocessing of multiple RNA-seq samples by automating the trimming process, ensuring consistency and saving valuable time during quality control checks.\n4. Quality Check Post-Trimming with FastQC \u0026amp; MultiQC It\u0026rsquo;s crucial to reassess the quality of your reads after trimming.\nfastqc *.gz multiqc . The quality significantly improves after trimming! :v:\n"},{"section":"Blog","slug":"/blog/qualitycheck/","title":"bulk RNA-seq(2):Quality Control with FastQC and MultiQC","description":"this is meta description","date":"May 22, 2022","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/multiqc_huefd6b0aaaa97d45f9ad7329e016c40fd_77022_420x0_resize_q100_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"280\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/multiqc_huefd6b0aaaa97d45f9ad7329e016c40fd_77022_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/multiqc_huefd6b0aaaa97d45f9ad7329e016c40fd_77022_100x100_fill_q100_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/multiqc_huefd6b0aaaa97d45f9ad7329e016c40fd_77022_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"RNA-seq","tags":"RNA-seq, Quality Control","content":"FastQC for Quality Checks FastQC provides a simple way to perform quality control checks on raw sequence data. Visit the FastQC homepage for download instructions and more information.\nInstalling Java Runtime Environment (JRE) FastQC requires Java to run. Install JRE using the command:\nsudo apt install default-jre Verify the installation by checking the Java version:\njava -version Installing FastQC To install FastQC, enter the following commands:\nsudo -i apt install fastqc fastqc -version Running FastQC Execute FastQC on all .gz files in the directory:\nfastqc *.gz This command analyzes all .gz files, producing an HTML report (XXXX_fastqc.html) for each sample, summarizing the quality metrics.\nInterpreting FastQC Results After running FastQC, you will receive an HTML report for each sample, which provides a comprehensive overview of various quality metrics. Understanding these metrics is crucial for assessing the quality of your RNA-seq data. Here\u0026rsquo;s a brief guide to interpreting some key sections of the FastQC report:\n1. Per Base Sequence Quality This section displays the quality scores across all bases at each position in the reads. Ideally, you want to see most of your reads with high scores (green and yellow), indicating reliable base calls. A drop in quality towards the end of reads is common, but significant quality drops may necessitate trimming.\n2. Per Sequence Quality Scores This graph shows the distribution of average quality scores across all reads. A left-skewed graph towards higher quality scores is desirable, indicating that most of your reads are of high quality.\n3. Per Base Sequence Content Examines the proportion of each base (A, T, C, G) at each position across all reads. In RNA-seq data, some variation at the beginning of reads is expected due to random hexamer priming in library preparation, but consistent biases or deviations in later positions may indicate contamination or other issues.\n4. Per Sequence GC Content This plot displays the distribution of GC content across all reads and compares it to a theoretical distribution. A significant deviation from the theoretical curve can suggest contamination or biased library preparation.\n5. Sequence Duplication Levels High levels of duplication can indicate over-amplification of certain regions. Some duplication is expected, especially in RNA-seq data, due to the nature of transcript abundance. However, unusually high duplication levels may warrant further investigation.\n6. Overrepresented Sequences Identifies sequences that appear more often than statistically expected. This could be a sign of contamination or highly abundant transcripts. It\u0026rsquo;s important to evaluate whether these overrepresented sequences are expected or indicative of an issue with the sample.\n7. Adapter Content Checks for the presence of adapter sequences. While some adapter contamination is expected, especially in shorter reads, significant adapter content may affect analyses and could require read trimming.\nMultiQC for Aggregated Reports MultiQC compiles results from various bioinformatics analyses, including FastQC, into a comprehensive report, streamlining quality assessment across multiple samples.\ninstalling conda Conda is an open-source package management and environment management system that simplifies package installation and management. For detailed installation instructions, visit the Conda installation guide .\nSetting Up Python Environment Create and activate a new Python environment using Conda to ensure compatibility and manage dependencies effectively:\nconda create --name py3.7 python=3.7 conda activate py3.7 python -version Installing MultiQC conda install -c bioconda -c conda-forge multiqc Running MultiQC multiqc . # Analyze all FastQC result files (.html) in the current directory Interpreting MultiQC Results The MultiQC report provides an at-a-glance summary of quality control metrics for all samples, enabling rapid identification of potential issues:\nSummary Table: Displays a high-level overview of QC metrics for each sample. Look for any warnings or failures that may require attention. FastQC Modules: Aggregated results of key FastQC metrics, such as \u0026ldquo;Per Base Sequence Quality\u0026rdquo; and \u0026ldquo;Sequence Duplication Levels\u0026rdquo;, across all samples. Consistency in quality across samples can be easily assessed here. Adapter Content: Provides a summary of adapter sequence contamination across samples. High levels of adapter content in multiple samples may indicate the need for adapter trimming. Overrepresented Sequences: Identifies common sequences across samples, useful for spotting contamination or highly abundant sequences. "},{"section":"Blog","slug":"/blog/rna-seq1concatenation/","title":"bulk RNA-seq(1):Concatenation of raw read files","description":"this is meta description","date":"May 19, 2022","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/concatenation_hu7249349a9a5ec8067785a059cd81390a_19293_420x0_resize_q100_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"109\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/concatenation_hu7249349a9a5ec8067785a059cd81390a_19293_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/concatenation_hu7249349a9a5ec8067785a059cd81390a_19293_100x100_fill_q100_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/concatenation_hu7249349a9a5ec8067785a059cd81390a_19293_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"RNA-seq","tags":"RNA-seq","content":"Concatenation of Raw Read Files To begin with, my operating environment is Linux Ubuntu 20.04.4, and I am working with 64 raw read fastq.gz files.\nWhat we need to accomplish first is the concatenation of 4 files into a single file. For instance:\nFile name (before) File name(after) LAB_273_17_\u0026hellip;_L001_R1_001.fastq.gz LAB_273_17_R1.fastq.gz LAB_273_17_\u0026hellip;_L002_R1_001.fastq.gz LAB_273_17_\u0026hellip;_L003_R1_001.fastq.gz LAB_273_17_\u0026hellip;_L004_R1_001.fastq.gz Tip\nLane Splitting: To increase throughput and reduce experimental bias, a sample\u0026rsquo;s DNA or RNA library might be sequenced across several lanes. This results in a separate data file for each lane, leading to multiple R1.fastq.gz files for a single sample.\nTo achieve this in Linux, open the terminal and execute the following script:\nfor name in *.fastq.gz; do printf \u0026#39;%s\\n\u0026#39; \u0026#34;${name%_*_*_R[12]*}\u0026#34; done | uniq | while read prefix; do cat \u0026#34;$prefix\u0026#34;*R1*.fastq.gz \u0026gt; \u0026#34;${prefix}_R1.fastq.gz\u0026#34; cat \u0026#34;$prefix\u0026#34;*R2*.fastq.gz \u0026gt; \u0026#34;${prefix}_R2.fastq.gz\u0026#34; done Subsequently, verify if the files have been successfully concatenated.\n"},{"section":"Blog","slug":"/blog/what_is_rna_seq/","title":"What is the RNA-seq analysis?","description":"this is meta description","date":"May 16, 2022","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/RNA-seq_hu4e571ce06a1b5f4636d562ec14a15535_411096_420x0_resize_q100_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"245\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/RNA-seq_hu4e571ce06a1b5f4636d562ec14a15535_411096_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/RNA-seq_hu4e571ce06a1b5f4636d562ec14a15535_411096_100x100_fill_q100_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/RNA-seq_hu4e571ce06a1b5f4636d562ec14a15535_411096_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"RNA-seq","tags":"RNA-seq","content":"Overall description of RNA-Seq The transcriptome has a high degree of complexity including multiple types of coding and non-coding RNA species, like mRNA, pre-mRNA, microRNA, and long ncRNA. To understand how the expression of a gene affects translation to proteins, messenger RNA (mRNA) molecules were the most frequently studied RNA species. Besides coding RNA, noncoding RNA molecules also play significant roles in cellular functions: Ribosomal RNAs and transfer RNAs are involved in mRNA translation. Small nuclear RNA (snRNAs) are involved in splicing. MicroRNA (miRNA) and piwi-interacting RNA (piRNA) regulate gene expression at the posttranscriptional level\u0026hellip;\nThe development of high-throughput next-generation sequencing (NGS) has revolutionized transcriptomics by enabling RNA analysis through the sequencing of complementary DNA (cDNA). This method is termed RNA sequencing (RNA-Seq).\nUnderstanding the Pandora box of the transcriptome is the key to connecting the information in our genome with its functional protein expression. RNA-seq analysis allows us to understand which genes are turned up/down in a cell/tissue, what their level of transcription is, and such changes-indicated diseases.\nRNA-Seq can be applied to investigate different populations of RNA, including total RNA, pre-mRNA, and noncoding RNA, such as microRNA and long ncRNA.\nAn RNA-seq workflow has several steps, which can be summarized as:\nRNA extraction\nReverse transcription into cDNA (cDNA library preparation)\nAdapted ligation\nAmplification\nSequencing\n1. RNA extraction Overview of RNA-seq (Kimberly.KR et al.,Cold Spring Harb Protoc. 2015 )\nThe first step in transcriptome sequencing is the isolation of RNA from a biological sample as the above figure shows. To ensure a trustable RNA-seq experiment, the RNA needs to have sufficient quality to produce a library for sequencing.\nCertain forms of contamination can be detected using UV spectroscopy and the calculation of absorbance ratios. Good quality RNA will have an A260/280 ratio of 1.7 to 2.1 and A260/230 of 2.0 to 2.2. A260/280 lower than 1.7 may indicate protein contamination, whereas A260/230 less than 1.8 may indicate the presence of organics (e.g. phenol or guanidine) leftover from the extraction protocol. Such contaminants may interfere with library preparation.\nThe measurement of RNA quality was usually performed by Agilent bioanalyzer: RNA Integrity Number (RIN).\nRIN assigns an electropherogram a value of 1 to 10, with 10 being the least degraded, the best quality. RIN represents the ratios of 28S to 18S ribosomal bands. The figure below shows the ideal fluorescence-length graph of RIN 10.\nInfo\nThe total RNA ratio is calculated by taking the ratio of the area under the 18S and 28S rRNA peaks to the total area under the graph, a large number here is desired, indicating much of the rRNA is still at these sizes and thus little to no degradation has occurred. An ideal ratio can be seen in the above figure, where almost all of the RNA is in the 18S and 28S RNA peaks. A small marker height is desired, indicating only small amounts of RNA have been degraded and proceeded to the smallest lengths. If marker \u0026gt; 18S or 28S, meaning RNA has been greatly degraded.\nHere is the sample RIN quality control graph. Most of the RINs are around 9, which means good quality of RNA.\n2. Library preparation In the next step, we need to choose an appropriate library preparation protocol\u0026mdash;\u0026mdash;\u0026mdash;-select RNA species!\nFor eukaryotic systems, researchers have a choice between poly(A) selection or rRNA depletion for enriching non-ribosomal RNA during library preparation. Prokaryotes require rRNA depletion methods as their mRNA is not polyadenylated. The decision tree in Figure 10 can help guide the selection of an enrichment method. Reference Basically, if the rRNA transcripts are not removed before library construction, they will consume the bulk of the sequencing reads, thus limiting the detection of DEGs.\n2.1 Poly(A) selection In a eukaryotic cell, 80% of the total RNAs are ribosomal RNA (rRNA), whereas the other 5% is polyadenylated positive (poly(A)+ ) mRNA. Poly(A) selection is the most common method for library preparation to provide efficient enrichment of poly(A) + transcripts including mRNAs and many non-coding RNAs, and also reduces the amounts of pre-mRNAs. In this approach, the 3′ poly-A tail of mRNA molecules is targeted using poly-T oligos that are covalently attached to a given substrate (e.g., magnetic beads).\n2.2 rRNA depletion rRNA-depleted removes cytoplasmic and mitochondrial rRNA and thus includes poly(A) + mRNA, as well as non-coding RNAs or protein-coding mRNAs that are not polyadenylated. In eukaryotes, this technique allows researchers to study both coding and non-coding transcripts.\nIn a previous study, the researchers showed that rRNA depletion captured more unique transcriptome features, whereas polyA+ selection outperformed rRNA depletion with higher exonic coverage and better accuracy of gene quantification. Reference 3. Sequencing In RNA-seq sequencing, there are paired-end sequencing and single-end sequencing.\nPaired-end sequencing is usually recommended for most applications as it provides richer data and permits longer library insert sizes. Paired-end sequencing allows us to sequence both ends of a fragment and generate high-quality, alignable sequence data.\nFor a single-read run, one Read 1 (R1) FASTQ file is created for each sample per flow cell lane. For a paired-end run, one R1 and one Read 2 (R2) FASTQ file is created for each sample for each lane. FASTQ files are compressed and created with the extension *.fastq.gz.\nCurrently, the Illumina HiSeq platform is the most commonly applied next-generation sequencing technology for RNA-Seq and has set the standard for NGS sequencing. The platform has two flow cells, each providing eight separate lanes for sequencing reactions to occur.\nNormally, we will get 8 read files (.fastq) for one sample. Each sample run in 4 separate lanes with paired-end:\nXXX_L001_R1_001.fastq\nXXX_L002_R1_001.fastq\nXXX_L003_R1_001.fastq\nXXX_L004_R1_001.fastq\nXXX_L001_R2_001.fastq\nXXX_L002_R2_001.fastq\nXXX_L003_R2_001.fastq\nXXX_L004_R2_001.fastq\nSo, we need to catthe files together into one.\n4. RNA-seq data analysis My RNA-seq analysis workflow is based on this figure. For more information, please refer to my other articles.\n"}]